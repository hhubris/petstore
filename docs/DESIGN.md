# Design: Pet Store

## Overview

This document describes *how* the Pet Store application is
built. It is the implementation companion to
[REQUIREMENTS.md](REQUIREMENTS.md), which describes *what*
the system does.

Every section in REQUIREMENTS.md should have a corresponding
design detail here. When making implementation changes,
update this document to keep it in sync.

## System Architecture

The application follows a classic three-tier architecture:

```
┌────────────────┐     ┌────────────────┐     ┌────────────┐
│  React + TS    │────▶│  Go Backend    │────▶│ PostgreSQL │
│  (Vite, TW)   │ HTTP│  (ogen router) │ SQL │            │
│  Port 5173     │◀────│  :8080 default │◀────│  Port 5432 │
└────────────────┘     └────────────────┘     └────────────┘
     Frontend              Backend               Database

┌────────────────┐
│  Go Client     │─── HTTP ───▶ Go Backend
│  (ogen client) │
└────────────────┘
```

- **Frontend** — React SPA served by Vite in dev; talks to
  the backend over HTTP (JSON).
- **Backend** — Go HTTP server with routing, validation, and
  serialization generated by ogen from the OpenAPI spec.
  Business logic lives in hand-written service and
  repository layers.
- **Go Client** — Generated Go HTTP client for the API,
  also produced by ogen from the same OpenAPI spec. Lives
  in the `client/` package at the project root. Used for
  CLI tooling, integration tests, and any Go consumer of
  the API.
- **Database** — PostgreSQL stores pets and users. Accessed
  only by the backend through `jackc/pgx/v5` (native pgx
  interface, no `database/sql` wrapper).

All tiers are independently deployable and communicate
over well-defined interfaces (HTTP, SQL).

## Backend Design

### Project Layout

```
cmd/
  server/
    main.go              # Server entrypoint
  client/
    main.go              # Client CLI entrypoint
client/
  oas_*.go               # ogen-generated client (DO NOT EDIT)
internal/
  api/
    api.yml              # OpenAPI 3.0 spec (source of truth)
    generate.go          # go:generate directives for ogen
    ogen-server.yml      # ogen config: server-only generation
    ogen-client.yml      # ogen config: client-only generation
    oas_*.go             # ogen-generated server (DO NOT EDIT)
    spec.go              # Embedded spec (!disable_spec) ✓
    empty_spec.go        # Nil spec (disable_spec) ✓
  db/
    db.go                # DBTX interface, sentinel errors
  middleware/
    middleware.go        # Middleware type, Chain helper ✓
    recovery.go          # Panic recovery ✓
    correlation.go       # X-Correlation-ID ✓
    logging.go           # Request logging ✓
    spec.go              # Swagger UI + spec serving ✓
  handler/
    handler.go           # Struct, interfaces, error mapping ✓
    add_pet.go           # POST /pets ✓
    delete_pet.go        # DELETE /pets/{id} ✓
    find_pets.go         # GET /pets ✓
    find_pet_by_id.go    # GET /pets/{id} ✓
    register_user.go     # POST /auth/register ✓
    login_user.go        # POST /auth/login ✓
    logout_user.go       # POST /auth/logout ✓
    get_current_user.go  # GET /auth/me ✓
  server/
    server.go            # Run/build/serve entry point ✓
  auth/
    user.go              # User domain model (private fields)
    repository.go        # UserRepository (DB queries) ✓
    security.go          # ogen SecurityHandler (JWT) ✓
    service.go           # AuthService (register, login) ✓
    service_test.go      # Service tests (mock repo) ✓
    authz.go             # RequireAdmin() helper ✓
    jwt.go               # Token creation and parsing ✓
    jwt_test.go          # JWT tests ✓
    context.go           # Context keys, ClaimsFromContext() ✓
    context_test.go      # Context round-trip tests ✓
  pet/
    repository.go        # PetRepository (DB queries) ✓
    service.go           # PetService (CRUD logic) ✓
scripts/
  migrate.sh               # Migration runner (sets session vars)
migrations/
  000001_create_pets_table.up.sql    / .down.sql
  000002_create_pets_indexes.up.sql  / .down.sql
  000003_create_users_table.up.sql   / .down.sql
  000004_create_users_indexes.up.sql / .down.sql
  000005_grant_petstore_privileges.up.sql / .down.sql
```

### ogen Workflow

The OpenAPI spec (`internal/api/api.yml`) is the single
source of truth for the API contract. Both server and
client code are generated from the same spec using
separate ogen configurations.

```
                    ┌─ ogen-server.yml ─▶ internal/api/oas_*.go
api.yml ──▶ ogen ──┤
                    └─ ogen-client.yml ─▶ client/oas_*.go
```

Generation is triggered via `go generate`:

```bash
mise run generate        # or: go generate ./internal/api/...
```

The `internal/api/generate.go` file contains two
`//go:generate` directives — one per ogen config.

**Server generation** (`ogen-server.yml`):
- `Handler` interface with one method per operation
- `SecurityHandler` interface for the `cookieAuth` scheme
- Router, parameter parsing, and request validation
- Server constructor: `ogen.NewServer(handler, security)`
- Unimplemented stub handler for scaffolding

**Client generation** (`ogen-client.yml`):
- Type-safe client struct with one method per operation
- Request/response types matching the spec schemas
- Client-side request validation

**Implementation rule:** Never edit generated `oas_*.go`
files in either `internal/api/` or `client/`. Implement
the `Handler` and `SecurityHandler` interfaces in separate
packages.

### Layered Architecture

```
HTTP request
  │
  ▼
Middleware (recovery, correlation ID, logging, spec)
  │
  ▼
ogen router + validation (generated)
  │
  ▼
Handler (thin — delegates to services)
  │
  ▼
Service (business logic, orchestration)
  │
  ▼
Repository (SQL queries, data mapping)
  │
  ▼
PostgreSQL
```

Each layer depends only on the layer below it. Handlers
never touch SQL directly. Services receive repository
interfaces for testability.

### Error Handling

- Return errors up the call stack; never `panic` in
  request-handling code.
- Wrap errors with context:
  `fmt.Errorf("pet service: find by id: %w", err)`
- Use sentinel errors (e.g., `ErrNotFound`, `ErrConflict`)
  in the repository layer; services and handlers translate
  these to HTTP status codes.
- ogen handles serialization of error responses using the
  `Error` schema (`code` + `message`).

### Structured Logging

- Use `log/slog` from the standard library.
- Create a logger in `main.go` and pass it via context or
  struct injection — no global logger.
- Log at appropriate levels:
  - `INFO` — request lifecycle, auth events
  - `WARN` — recoverable issues (e.g., rate limit hit)
  - `ERROR` — unrecoverable failures
- Never log passwords, tokens, or password hashes.

## Authentication & Authorization Design

### JWT Lifecycle

```
Register ──▶ Login ──▶ Cookie set ──▶ Request + cookie
                                          │
                                          ▼
                                    SecurityHandler
                                    validates JWT
                                          │
                                          ▼
                                    Handler runs
                                          │
                                          ▼
                                    Logout clears cookie
```

1. User registers via `POST /auth/register` (no auth).
2. User logs in via `POST /auth/login`; server returns
   an `access_token` HttpOnly cookie containing a JWT.
3. Subsequent requests include the cookie automatically.
4. The ogen `SecurityHandler` extracts and validates the
   JWT on protected endpoints.
5. Logout via `POST /auth/logout` clears the cookie by
   setting `MaxAge=0`.

### SecurityHandler Implementation

ogen generates a `SecurityHandler` interface with a
`HandleCookieAuth` method. The implementation in
`internal/auth/security.go`:

1. Parses and validates the JWT via
   `TokenConfig.ParseToken()` (signature, expiration).
2. Extracts `Claims` (`UserID`, `Role`).
3. Checks an `adminOperations` map — since ogen does not
   populate `CookieAuth.Roles` from `x-required-role`, the
   handler maintains its own map of operations that require
   the `admin` role (`AddPet`, `DeletePet`).
4. Stores `Claims` in the request context via
   `ContextWithClaims()`.
5. Returns `ErrInvalidToken` (401) or `ErrForbidden` (403)
   on failure.

### Password Hashing Flow

```
Registration:
  plaintext password ──▶ bcrypt.GenerateFromPassword()
                         ──▶ store hash in users.password_hash

Login:
  plaintext password ──▶ bcrypt.CompareHashAndPassword()
                         against stored hash
```

- Library: `golang.org/x/crypto/bcrypt`, default cost.
- The 72-byte bcrypt input limit is enforced at the API
  schema level (`maxLength: 72` on password fields).

### Role Enforcement

- Roles are embedded in the JWT `role` claim.
- The `SecurityHandler` uses an `adminOperations` map to
  determine which operations require the `admin` role
  (ogen does not extract `x-required-role` at runtime).
- A `RequireAdmin()` helper in `internal/auth/authz.go`
  provides a reusable check for handler-level use.
- Role changes require re-login (new JWT) since the role
  is in the token, not looked up per-request.

### Origin Header Validation (CSRF)

- `SameSite=Strict` on the cookie is the primary CSRF
  defense.
- Additionally, state-changing requests (POST, DELETE)
  validate the `Origin` header against `FRONTEND_URL`.
- This check runs in middleware before the handler.

## Database Design

### Table DDL

**pets:**

```sql
CREATE TABLE pets (
    id   BIGSERIAL PRIMARY KEY,
    name TEXT      NOT NULL,
    tag  TEXT
);
```

**users:**

```sql
CREATE TABLE users (
    id            BIGSERIAL    PRIMARY KEY,
    name          TEXT         NOT NULL,
    email         TEXT         NOT NULL,
    password_hash TEXT         NOT NULL,
    role          TEXT         NOT NULL DEFAULT 'customer'
                  CHECK (role IN ('admin', 'customer')),
    created_at    TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_at    TIMESTAMPTZ  NOT NULL DEFAULT now()
);
CREATE UNIQUE INDEX idx_users_email ON users (email);
```

### Indexes

| Index            | Table | Columns | Type   | Purpose              |
|------------------|-------|---------|--------|----------------------|
| `pets_pkey`      | pets  | id      | PK     | Primary key (auto)   |
| `idx_pets_tag`   | pets  | tag     | B-tree | Tag filter queries   |
| `users_pkey`     | users | id      | PK     | Primary key (auto)   |
| `idx_users_email`| users | email   | Unique | Login lookup, dedup  |

### Privilege Grants

The `petstore` application user receives minimal
privileges:

```sql
GRANT SELECT, INSERT, UPDATE, DELETE
    ON pets, users TO petstore;
GRANT USAGE, SELECT
    ON ALL SEQUENCES IN SCHEMA public TO petstore;
```

The `postgres` superuser is used only for migrations and
administrative tasks.

### Migration Strategy

- Tool: `golang-migrate/migrate` with the PostgreSQL
  driver.
- Files live in `migrations/`, numbered sequentially with
  separate up/down files:
  ```
  000001_create_pets_table.up.sql    / .down.sql
  000002_create_pets_indexes.up.sql  / .down.sql
  000003_create_users_table.up.sql   / .down.sql
  000004_create_users_indexes.up.sql / .down.sql
  000005_grant_petstore_privileges.up.sql / .down.sql
  ```
- Each table creation and its indexes are in separate
  migrations.
- The `scripts/migrate.sh` wrapper bootstraps the
  `petstore` role and database via `psql` before running
  `golang-migrate`. Role and database creation use `psql`
  because `CREATE DATABASE` cannot run inside a
  transaction.
- Migrations run against the `petstore` database (not
  `postgres`).
- **Dev:** Migrations run automatically on server startup.
- **Prod:** Migrations run explicitly via CLI before deploy.
- Down migrations exist for every up migration to support
  rollback.

### Docker Volume

The PostgreSQL container uses a named Docker volume
(`petstore-data`) mounted at `/var/lib/postgresql` to
persist data across container restarts. This means
`db:stop` followed by `db:start` retains all data.
`db:clean` explicitly removes the volume for a fresh start.

### Database Lifecycle Tasks

mise provides a set of tasks for managing the database
container:

| Task         | Description                              |
|--------------|------------------------------------------|
| `db`         | Start database and run migrations        |
| `db:start`   | Start container with persistent volume   |
| `db:stop`    | Stop and remove the container            |
| `db:clean`   | Stop container and remove the volume     |
| `db:migrate` | Run migrations via `scripts/migrate.sh`  |

### Connection Management

- The connection string is built from individual
  environment variables (`PETSTORE_USER`,
  `PETSTORE_PASSWORD`, `DB_HOST`, `DB_PORT`,
  `DB_SSL_ENABLE`) by `db.connString()`.
- Uses `pgxpool.Pool` from `jackc/pgx/v5` for connection
  pooling (native pgx, not `database/sql`).
- Pool settings are configured via `pgxpool.Config`
  defaults.

### DBTX Interfaces

Each repository package defines its own unexported `dbtx`
interface containing only the pgx methods it actually
uses. For example, `auth` needs only `QueryRow`, while
`pet` needs `Query`, `QueryRow`, and `Exec`. These
interfaces are satisfied by `*pgxpool.Pool`, `pgx.Tx`, and
`pgxmock` — enabling repositories to work with a live
pool, inside a transaction, or under test.

Sentinel errors `db.ErrNotFound` and `db.ErrConflict` in
`internal/db` let upper layers translate to HTTP status
codes without importing pgx.

### Connection Management

`db.DB` encapsulates database connectivity. It delegates
`Query`, `QueryRow`, and `Exec` to the underlying pool,
so no package outside `internal/db` ever imports pgx for
connection management:

- **`New(ctx)`** — builds a connection string from
  individual env vars (`PETSTORE_USER`,
  `PETSTORE_PASSWORD`, `DB_HOST`, `DB_PORT`,
  `DB_SSL_ENABLE`), connects to the database, and pings
  to verify connectivity. Returns `*db.DB`.
- **`Query`**, **`QueryRow`**, **`Exec`** — delegate to
  the underlying connection pool.
- **`Close()`** — releases all database resources.

Each repository package defines its own unexported `dbtx`
interface with only the methods it needs:

- `auth` requires only `QueryRow`
- `pet` requires `Query`, `QueryRow`, and `Exec`

`*db.DB` satisfies both interfaces via duck typing, as
does `pgxmock` in tests. This follows the Go convention
of defining interfaces at the consumer, not the
implementor.

### Transaction Boundaries

- Registration (insert user) runs in a single query — no
  explicit transaction needed.
- Operations touching multiple tables use explicit
  transactions via `pgx.Tx`.
- Repository methods accept the `DBTX` interface,
  compatible with both `*pgxpool.Pool` and `pgx.Tx`.

### Pet Domain Model

`internal/pet/pet.go` defines a `Pet` struct with domain
types (`*string` for the nullable tag) rather than
ogen-generated types. This decouples the pet package from
the API layer, matching the auth package's approach.

### Pet Repository

`internal/pet/repository.go` — returns `pet.Pet` domain
types. The nullable `tag` column scans directly into
`*string`.

| Method     | SQL                                  | Notes                                |
|------------|--------------------------------------|--------------------------------------|
| `Create`   | `INSERT ... RETURNING id, name, tag` | Scans tag directly into `*string`    |
| `FindByID` | `SELECT ... WHERE id = $1`           | Returns `db.ErrNotFound` on no row   |
| `FindAll`  | `SELECT ...` + dynamic filters       | Optional `tags` (IN) and `limit`     |
| `Delete`   | `DELETE ... WHERE id = $1`           | Returns `db.ErrNotFound` on 0 rows   |

### Pet Service

`internal/pet/service.go` contains the business logic
layer for pets, sitting between the (future) HTTP handler
and the repository layer.

**Interface-based dependency injection:**

The service depends on a `Repository` interface rather than
the concrete `PetRepository`. This enables testing with a
hand-written mock — no pgxmock or database needed:

```go
type Repository interface {
    Create(ctx context.Context,
        name string, tag *string,
    ) (Pet, error)
    FindByID(ctx context.Context,
        id int64,
    ) (Pet, error)
    FindAll(ctx context.Context,
        tags []string, limit *int32,
    ) ([]Pet, error)
    Delete(ctx context.Context,
        id int64,
    ) error
}
```

`PetRepository` satisfies this interface via Go duck
typing — no explicit `implements` declaration needed.

**Constructor:** `NewService(repo Repository) *Service`

**Methods:**

| Method      | Inputs                    | Returns         | Notes                    |
|-------------|---------------------------|-----------------|--------------------------|
| `CreatePet` | ctx, name, tag            | `Pet, error`    | Delegates to repo.Create |
| `GetPet`    | ctx, id                   | `Pet, error`    | Delegates to repo.FindByID |
| `ListPets`  | ctx, tags, limit          | `[]Pet, error`  | Delegates to repo.FindAll |
| `DeletePet` | ctx, id                   | `error`         | Delegates to repo.Delete |

### Pet Service Tests

`internal/pet/service_test.go` uses an external test
package (`package pet_test`) with a hand-written `mockRepo`
implementing the `Repository` interface. Each mock function
is set per-test via function fields.

Table-driven test cases:

| Test                  | Case       | Assertion                      |
|-----------------------|------------|--------------------------------|
| `TestServiceCreatePet`| success    | Returns pet with correct fields|
| `TestServiceCreatePet`| repo error | Returns error                  |
| `TestServiceGetPet`   | found      | Returns pet with correct ID    |
| `TestServiceGetPet`   | not found  | Returns `db.ErrNotFound`       |
| `TestServiceListPets` | success    | Returns expected count         |
| `TestServiceListPets` | empty      | Returns nil slice              |
| `TestServiceDeletePet`| success    | Returns nil error              |
| `TestServiceDeletePet`| not found  | Returns `db.ErrNotFound`       |

### User Repository

`internal/auth/repository.go` — returns `auth.User`
domain model (contains `PasswordHash` and timestamps
that must not leak to the API).

| Method        | SQL                              | Notes                                       |
|---------------|----------------------------------|---------------------------------------------|
| `Create`      | `INSERT ... RETURNING id, ...`   | Returns `db.ErrConflict` on unique violation |
| `FindByEmail` | `SELECT ... WHERE email = $1`    | Returns `db.ErrNotFound` on no row           |
| `FindByID`    | `SELECT ... WHERE id = $1`       | Returns `db.ErrNotFound` on no row           |

### User Domain Model

`internal/auth/user.go` defines a `User` struct separate
from `api.AuthUser`. It includes `PasswordHash`,
`CreatedAt`, and `UpdatedAt` — fields that must never
appear in API responses. Mapping from `User` to
`api.AuthUser` happens in the service layer.

### Auth Service

`internal/auth/service.go` contains the business logic
layer for authentication, sitting between the (future)
HTTP handler and the repository/JWT layers.

**Interface-based dependency injection:**

The service depends on a `Repository` interface rather than
the concrete `UserRepository`. This enables testing with a
hand-written mock — no pgxmock or database needed:

```go
type Repository interface {
    Create(ctx context.Context,
        name, email, passwordHash, role string,
    ) (User, error)
    FindByEmail(ctx context.Context,
        email string,
    ) (User, error)
    FindByID(ctx context.Context,
        id int64,
    ) (User, error)
}
```

`UserRepository` satisfies this interface via Go duck
typing — no explicit `implements` declaration needed.

**Constructor:** `NewService(repo Repository,
token *TokenConfig) *Service`

**Methods:**

| Method     | Inputs                       | Returns            | Notes                                           |
|------------|------------------------------|--------------------|--------------------------------------------------|
| `Register` | ctx, name, email, password   | `User, error`      | Hashes with bcrypt; role is always `"customer"`  |
| `Login`    | ctx, email, password         | `string, User, error` | Returns JWT + user; maps not-found to `ErrInvalidCredentials` |
| `GetUser`  | ctx, id                      | `User, error`      | Delegates to `repo.FindByID`                     |

**Error mapping:**

- `db.ErrNotFound` on login → `ErrInvalidCredentials`
  (prevents email enumeration)
- `db.ErrConflict` on register → propagated as-is
  (handler maps to 409)
- `db.ErrNotFound` on `GetUser` → propagated as-is
  (handler maps to 404)
- bcrypt mismatch on login → `ErrInvalidCredentials`

**Dependencies:** `golang.org/x/crypto/bcrypt` for
password hashing at `bcrypt.DefaultCost`.

### Auth Service Tests

`internal/auth/service_test.go` uses an external test
package (`package auth_test`) with a hand-written
`mockRepo` implementing the `Repository` interface. Each
mock function is set per-test via function fields.

Table-driven test cases:

| Test         | Case             | Assertion                      |
|--------------|------------------|--------------------------------|
| `Register`   | success          | Returns user; password hashed  |
| `Register`   | duplicate email  | Returns `db.ErrConflict`       |
| `Login`      | success          | Returns non-empty JWT + user   |
| `Login`      | unknown email    | Returns `ErrInvalidCredentials`|
| `Login`      | wrong password   | Returns `ErrInvalidCredentials`|
| `GetUser`    | success          | Returns user with correct ID   |
| `GetUser`    | not found        | Returns `db.ErrNotFound`       |

### Auth Context

`internal/auth/context.go` provides helpers to store and
retrieve `Claims` in a `context.Context`, using the
standard unexported-key pattern to avoid collisions.

- **`ContextWithClaims(ctx, Claims) context.Context`** —
  returns a child context carrying the given Claims.
- **`ClaimsFromContext(ctx) (Claims, bool)`** — extracts
  Claims from the context, returning false if absent.

The `SecurityHandler` calls `ContextWithClaims` after
validating the JWT, and downstream handlers call
`ClaimsFromContext` to access the authenticated user's ID
and role without a database lookup.

Only `Claims` (UserID + Role) is stored — not the full
`User` — because the SecurityHandler only has the JWT.
Handlers that need the full user can call
`service.GetUser()`.

## Handler Design

### One File Per Endpoint

Each ogen `Handler` method lives in its own file under
`internal/handler/`, named after the operation (e.g.,
`add_pet.go`, `login_user.go`). This keeps files small and
navigable in larger APIs. Common code (struct, interfaces,
mappers, error handling) lives in `handler.go`.

### Service Interfaces

The handler depends on `PetService` and `AuthService`
interfaces — not the concrete `*pet.Service` or
`*auth.Service` types. This enables mock injection in tests
without importing repository or database packages:

```go
type PetService interface {
    CreatePet(ctx, name, tag) (pet.Pet, error)
    GetPet(ctx, id) (pet.Pet, error)
    ListPets(ctx, tags, limit) ([]pet.Pet, error)
    DeletePet(ctx, id) error
}

type AuthService interface {
    Register(ctx, name, email, password) (auth.User, error)
    Login(ctx, email, password) (string, auth.User, error)
    GetUser(ctx, id) (auth.User, error)
}
```

### Response Writer Context Pattern

ogen v1.18.0 does not expose `http.ResponseWriter` to handler
methods. To set and clear cookies for login/logout, the
handler layer uses a context-injection pattern:

1. `WrapWithResponseWriter(handler)` — HTTP middleware that
   stores the `ResponseWriter` in each request's context.
2. `responseWriterFromContext(ctx)` — retrieves the writer
   inside handler methods.
3. Used by `internal/server` when wiring up the ogen server:
   `handler.WrapWithResponseWriter(ogenServer)`.

### Error Mapping

`NewError` translates sentinel errors from the service and
database layers into ogen `ErrorStatusCode` responses:

| Sentinel Error              | HTTP Status |
|-----------------------------|-------------|
| `db.ErrNotFound`            | 404         |
| `db.ErrConflict`            | 409         |
| `auth.ErrInvalidCredentials`| 401         |
| `auth.ErrUnauthorized`      | 401         |
| `auth.ErrForbidden`         | 403         |
| `auth.ErrInvalidToken`      | 401         |
| (default)                   | 500         |

### Domain-to-API Mappers

Two unexported helpers convert domain models to ogen types:

- `petToAPI(pet.Pet) api.Pet` — maps `*string` tag to
  `OptString`
- `userToAPI(auth.User) api.AuthUser` — maps role string to
  `AuthUserRole` enum

### Handler Tests

Tests use an external test package (`handler_test`) with
hand-written mock services following the same function-field
pattern as the service tests. Table-driven tests cover:

- Happy path for each endpoint
- Service errors producing correct HTTP status codes
- Login: cookie set with correct name/value/flags
- Logout: cookie cleared (MaxAge=-1)
- Missing response writer in context returns error

## Server Package Design

### Overview

`internal/server` wires all dependencies together and
manages the HTTP server lifecycle. It exposes a single
public function, `Run(ctx context.Context) error`, keeping
`cmd/server/main.go` minimal (signal handling + call `Run`).

### Architecture

`Run` delegates to two internal helpers:

```
Run(ctx)
  │
  ├─ read env vars: ADDRESS, JWT_SECRET, ENVIRONMENT
  │
  ├─ db.New(ctx)
  │    └─ builds conn string from env vars, connects, pings
  │         → *db.DB (caller defers Close)
  │
  ├─ build(database, jwtSecret, secure)
  │    │
  │    ├─ auth.NewTokenConfig
  │    ├─ auth.NewUserRepository → auth.NewService
  │    ├─ auth.NewSecurityHandler
  │    ├─ pet.NewPetRepository → pet.NewService
  │    ├─ handler.New
  │    ├─ api.NewServer
  │    ├─ handler.WrapWithResponseWriter
  │    └─ middleware.Chain (Recovery, CorrelationID,
  │         Logging, Spec)
  │         → http.Handler
  │
  └─ serve(ctx, addr, handler)
       │
       ├─ http.Server.ListenAndServe (goroutine)
       ├─ <-ctx.Done()
       └─ srv.Shutdown (10s timeout)
```

### Environment Variables

| Variable        | Required | Default     | Notes                                     |
|-----------------|----------|-------------|-------------------------------------------|
| `ADDRESS`       | No       | `:8080`     | Listen address (host:port)                |
| `PETSTORE_USER` | Yes      | —           | Database application user                 |
| `PETSTORE_PASSWORD` | Yes  | —           | Database application user password        |
| `DB_HOST`       | No       | `localhost` | Database host                             |
| `DB_PORT`       | No       | `5432`      | Database port                             |
| `DB_SSL_ENABLE` | No       | `false`     | Set to `true` to require SSL              |
| `JWT_SECRET`    | Yes      | —           | Min 32 bytes                              |
| `ENVIRONMENT`   | No       | `production`| Set to `development` for insecure cookies |

### Secure Cookie Flag

The `secure` bool passed to `handler.New` controls the
`Secure` attribute on HTTP cookies. It defaults to `true`
(production). Setting `ENVIRONMENT=development` sets it to
`false` for local HTTP development.

### Graceful Shutdown

1. `Run` receives a cancellable context (from
   `signal.NotifyContext` in main).
2. `serve` starts `ListenAndServe` in a goroutine and
   blocks on `<-ctx.Done()`.
3. On cancellation, `srv.Shutdown` is called with a 10s
   timeout to drain in-flight requests.
4. After `serve` returns, `Run` defers `database.Close()`
   to release all database connections.

## Middleware Stack

### Overview

The server applies a middleware chain around the ogen
handler to provide cross-cutting concerns. Middleware is
applied outermost-first:

```
Recovery → CorrelationID → Logging → Spec → WrapWithResponseWriter(ogen)
```

### Ordering Rationale

1. **Recovery** is outermost so it catches panics from
   every layer below, including other middleware.
2. **CorrelationID** populates the context before Logging
   reads it, ensuring every log line includes the ID.
3. **Logging** wraps the response writer to capture the
   status code, then logs after the request completes.
4. **Spec** checks the path prefix and serves docs or
   passes through to the ogen handler.

### `middleware.go` — Type and Chain Helper

```go
type Middleware func(http.Handler) http.Handler

func Chain(h http.Handler, mws ...Middleware) http.Handler
```

`Chain` applies middleware in reverse order so the first
argument is the outermost wrapper.

### `recovery.go` — Panic Recovery

- Uses `defer recover()` around `next.ServeHTTP`.
- Logs the panic value and stack trace via `slog.Error`.
- Writes a 500 JSON response matching the ogen Error
  schema: `{"code":500,"message":"internal server error"}`.

### `correlation.go` — Correlation ID

- Reads the `X-Correlation-ID` request header; if absent,
  generates a new ULID via `ulid.Make()`.
- Stores the ID in the request context (unexported key).
- Sets `X-Correlation-ID` on the response header.
- Exports `GetCorrelationID(ctx) string` for use by the
  Logging middleware and application code.

### `logging.go` — Request Logging

- Wraps `http.ResponseWriter` with `responseCapture` to
  intercept the status code (overrides `WriteHeader` and
  `Write`).
- After `next.ServeHTTP` completes, logs: method, path,
  status, duration, and correlation_id.
- Uses `slog.Info` for status < 500, `slog.Error` for 5xx.

### `spec.go` — OpenAPI Spec and Swagger UI

- Uses `http.NewServeMux` internally to route:
  - `GET /docs/openapi.yml` — serves the embedded spec
    with `Content-Type: application/x-yaml`.
  - `GET /docs` — serves the Swagger UI from
    `go-openapi/runtime/middleware.SwaggerUI` (loads JS
    from unpkg.com CDN).
  - All other paths pass through to the next handler.
- The spec is provided by `api.Spec()`, which returns a
  copy of the embedded YAML. If `api.Spec()` returns nil
  (see build tags below), the middleware is a no-op
  passthrough.

### Spec Build Tags

The OpenAPI spec embedding uses build tags so it can be
excluded from production binaries:

- `internal/api/spec.go` (`//go:build !disable_spec`) —
  embeds `api.yml` and returns a copy from `api.Spec()`.
- `internal/api/empty_spec.go` (`//go:build disable_spec`)
  — `api.Spec()` returns nil.

Default builds include the spec. To exclude it:

```bash
go build -tags=disable_spec ./cmd/server
```

When excluded, the Spec middleware becomes a passthrough
and no Swagger UI or YAML endpoints are served.

### Dependencies

- `github.com/oklog/ulid/v2` — ULID generation for
  correlation IDs.
- `github.com/go-openapi/runtime/middleware` — Swagger UI
  handler.

## Frontend Design

### Component Hierarchy

```
App
├── AuthProvider (Context + useReducer)
│   ├── NavBar
│   │   ├── Logo / Home link
│   │   ├── User name + role (when logged in)
│   │   └── Login / Register links (when logged out)
│   ├── Routes
│   │   ├── /login         → LoginPage
│   │   ├── /register      → RegisterPage
│   │   ├── /pets           → PetListPage
│   │   ├── /pets/:id       → PetDetailPage
│   │   ├── /pets/new       → AddPetPage (protected, admin)
│   │   └── *               → NotFoundPage
│   └── ToastContainer (success/error feedback)
```

### Routing Structure

React Router handles client-side routing. Routes are split
into public and protected:

| Path           | Component      | Auth     | Role  |
|----------------|----------------|----------|-------|
| `/login`       | LoginPage      | Public   | —     |
| `/register`    | RegisterPage   | Public   | —     |
| `/pets`        | PetListPage    | Public   | —     |
| `/pets/:id`    | PetDetailPage  | Public   | —     |
| `/pets/new`    | AddPetPage     | Required | Admin |

### Auth State Management

```
AuthContext (React Context)
  │
  ├── state: { user: AuthUser | null, loading: boolean }
  │
  └── dispatch: (action) => void
       ├── LOGIN_SUCCESS  → set user
       ├── LOGOUT         → clear user
       └── SET_LOADING    → toggle loading
```

- `AuthProvider` wraps the app and calls `GET /auth/me` on
  mount to restore session from the HttpOnly cookie.
- Components access auth state via a `useAuth()` hook.
- Login sets user state; logout clears it and calls
  `POST /auth/logout`.

### Service Layer Pattern

All API calls go through `frontend/src/services/`. No
component calls `fetch` directly.

```
frontend/src/services/
  api.ts          # Base fetch wrapper (credentials, JSON)
  petService.ts   # findPets, getPet, addPet, deletePet
  authService.ts  # register, login, logout, getCurrentUser
```

The base `api.ts` module:
- Sets `credentials: 'include'` for cookie handling.
- Sets `Content-Type: application/json`.
- Parses error responses into a consistent format.
- Provides typed wrapper functions for GET, POST, DELETE.

### Protected Route Redirect Flow

```
User visits /pets/new (protected)
  │
  ├── Not authenticated?
  │     └── Redirect to /login?redirect=/pets/new
  │           └── After login → redirect to /pets/new
  │
  └── Authenticated but not admin?
        └── Redirect to /pets (or show 403 message)
```

A `ProtectedRoute` wrapper component checks auth state
and role before rendering the child route.

## API Design

### Base Path and CORS

- All endpoints are served under `/api/v1/` (ogen base
  path configuration).
- CORS middleware allows requests from `FRONTEND_URL` with:
  - Allowed methods: GET, POST, DELETE, OPTIONS
  - Allowed headers: Content-Type
  - Credentials: true (for cookies)
  - Max age: 3600s

### Request/Response Flow

```
Client request
  │
  ▼
CORS middleware
  │
  ▼
ogen router (matches path + method)
  │
  ▼
ogen parameter parsing + validation
  │
  ▼
ogen SecurityHandler (if endpoint has security)
  │
  ▼
Handler method (generated interface)
  │
  ▼
ogen response serialization
  │
  ▼
Client response
```

### Error Response Format

All errors use the `Error` schema:

```json
{
  "code": 404,
  "message": "pet not found"
}
```

Standard HTTP status codes:
- `200` — success (list, get, login)
- `201` — created (register)
- `204` — no content (delete, logout)
- `400` — bad request (validation failure)
- `401` — unauthorized (missing/invalid token)
- `403` — forbidden (insufficient role)
- `404` — not found
- `409` — conflict (duplicate email)
- `500` — internal server error

### Cookie Handling

- **Login:** Response sets `Set-Cookie: access_token=<jwt>`
  with HttpOnly, Secure, SameSite=Strict, Path=/,
  MaxAge=3600.
- **Logout:** Response sets the same cookie with
  `MaxAge=0` to clear it.
- **Secure flag:** `true` in production; configurable to
  `false` in dev (plain HTTP on localhost).

## Go Client Design

### Purpose

The Go client provides a type-safe, generated HTTP client
for the Pet Store API. It is used by:
- The CLI tool (`cmd/client/main.go`)
- Integration tests that exercise the API end-to-end
- Any future Go service that consumes the API

### Package Layout

```
client/
  oas_*.go       # ogen-generated client code (DO NOT EDIT)
cmd/
  client/
    main.go      # CLI entrypoint
```

The `client/` package lives at the project root (not under
`internal/`) so it can be imported by external Go modules
if needed.

### Code Generation

Client code is generated from the same `api.yml` spec as
the server, using a separate ogen config
(`internal/api/ogen-client.yml`) that enables only
client-related features:

- `paths/client` — client struct and methods
- `client/request/validation` — validate requests before
  sending

The `--clean` flag ensures stale generated files are
removed on each run. Generation is controlled by
`internal/api/generate.go` and invoked via
`mise run generate`.

### Cookie / Auth Handling

The ogen-generated client accepts a `SecuritySource`
interface for authentication. The client implementation
provides the `access_token` cookie value obtained from a
prior login call. Cookie jar management or manual header
injection can be used depending on the use case.

## Configuration & Environment

### 12-Factor Approach

The application follows
[12-Factor App](https://12factor.net/) principles:

| Factor           | Implementation                      |
|------------------|-------------------------------------|
| Codebase         | Single repo, git                    |
| Dependencies     | go.mod, package.json                |
| Config           | Environment variables               |
| Backing services | PostgreSQL via env vars              |
| Build/release/run| mise tasks, Vite build              |
| Processes        | Stateless server                    |
| Port binding     | ADDRESS env var                     |
| Concurrency      | Go goroutines per request           |
| Disposability    | Graceful shutdown on SIGTERM        |
| Dev/prod parity  | Same stack, minimal differences     |
| Logs             | Structured JSON to stdout           |
| Admin processes  | Migration CLI, seed scripts         |

### Secrets Management

- Secrets (`POSTGRES_PASSWORD`, `PETSTORE_PASSWORD`,
  `JWT_SECRET`) are stored in
  `.config/mise/mise.local.toml`, which is gitignored.
  Values use mise's age encryption (`{ age = "..." }`
  syntax).
- Never committed in plaintext or stored in `.env` files
  in version control. The local config file stays on the
  developer's machine only.
- Accessed at runtime via `mise env` which decrypts and
  injects them into the process environment.

### Dev vs. Prod Differences

| Concern             | Dev                | Prod             |
|---------------------|--------------------|------------------|
| Cookie Secure flag  | `false`            | `true`           |
| Migrations          | Auto-run on start  | CLI before deploy|
| Log format          | Text (human-read)  | JSON             |
| Frontend            | Vite dev server    | Static build     |
| CORS origin         | `localhost:5173`   | Production URL   |

## Testing Strategy

### Go Tests

- **Style:** Table-driven tests using `testing.T` and
  subtests (`t.Run`).
- **Service tests:** Mock the repository interface; test
  business logic in isolation.
- **Handler tests:** Use `httptest` to spin up the ogen
  server with real handlers and mock services.
- **Repository tests:** Unit tests using `pgxmock` to mock
  the `DBTX` interface; no live database required.
- **Auth tests:** Token creation/parsing, expired token
  rejection, role enforcement, bcrypt round-trip.
- **Run:** `mise run api:test` (wraps `go test ./...`).

### Frontend Tests

- **Component tests:** React Testing Library for
  rendering and user interaction.
- **Service layer tests:** Mock `fetch` to verify correct
  request construction and response parsing.
- **Auth flow tests:** Verify context updates on login/
  logout, protected route redirects.
- **Run:** `mise run ui:test`.

### Auth-Specific Test Cases

| Scenario                     | Expected Result         |
|------------------------------|-------------------------|
| Valid JWT                    | Request proceeds        |
| Expired JWT                  | 401 Unauthorized        |
| Tampered JWT signature       | 401 Unauthorized        |
| Missing cookie               | 401 Unauthorized        |
| Customer accessing admin ep  | 403 Forbidden           |
| Admin accessing admin ep     | Request proceeds        |
| Login with wrong password    | 401 Unauthorized        |
| Register with duplicate email| 409 Conflict            |
| Password > 72 bytes          | 400 Bad Request         |
| Rate limit exceeded          | 429 Too Many Requests   |

## Decision Log

| #  | Decision                       | Choice                    | Rationale                                                    |
|----|--------------------------------|---------------------------|--------------------------------------------------------------|
| 1  | API specification tool         | ogen (OpenAPI 3.0)        | Type-safe generated server; spec is single source of truth   |
| 2  | GET /pets public access        | No auth required          | Allows browsing without account                              |
| 3  | Auth token delivery            | HttpOnly cookie           | Prevents XSS token theft; browser sends automatically        |
| 4  | JWT algorithm                  | HS256                     | Simple shared-secret; sufficient for single-service deploy   |
| 5  | Refresh tokens                 | None; 1hr access token    | Simpler implementation; re-login on expiry                   |
| 6  | CSRF protection                | SameSite=Strict + Origin  | Strongest browser protection; no separate token needed       |
| 7  | Role storage                   | JWT claims                | Avoids DB lookup per request; role changes require re-login  |
| 8  | Password hashing               | bcrypt, default cost      | Industry standard; 72-byte limit enforced in schema          |
| 9  | Admin creation                 | Manual / seed script      | No self-service admin promotion                              |
| 10 | Database migration tool        | golang-migrate            | SQL-based, supports up/down, widely adopted                  |
| 11 | Frontend state management      | Context + useReducer      | Built-in React; avoids external dependency for simple state  |
| 12 | CSS framework                  | Tailwind CSS              | Utility-first; consistent with project conventions           |
| 13 | Frontend routing               | React Router              | De facto standard for React SPAs                             |
| 14 | API base path                  | /api/v1/                  | Versioned; separates API from frontend routes                |
| 15 | Logging                        | slog (std library)        | No external dependency; structured output                    |
| 16 | DB driver                      | pgx/v5 (native)           | Direct pgx interface; no database/sql overhead               |
| 17 | Dev migration strategy         | Auto-run on startup       | Fast iteration; prod uses explicit CLI                       |
| 18 | Service layer pattern          | Interface-based           | Enables mock injection for testing                           |
| 19 | Rate limiting                  | Per-IP on auth endpoints  | Mitigates brute-force without external infrastructure        |
| 20 | Secrets management             | mise.local.toml (gitignored, age-encrypted) | Never in repo; decrypted at runtime by mise          |
| 21 | Go client generation           | ogen from same spec       | Type-safe client; single source of truth for both sides      |
| 22 | Client package location        | `/client` (root)          | Importable by external modules; separate from internal code  |
| 23 | Separate ogen configs          | server.yml + client.yml   | Independent feature sets; server doesn't ship client code    |
| 24 | Repository DB abstraction      | DBTX interface            | Works with pool, transaction, or mock; no concrete dep       |
| 25 | Repository test approach       | pgxmock (unit tests)      | Fast, no live DB; validates SQL expectations                 |
| 26 | Pet repo return type           | pet.Pet domain model      | Decouples pet pkg from ogen; handler maps to api types       |
| 27 | User repo return type          | auth.User domain model    | Keeps PasswordHash/timestamps out of API layer               |
| 28 | Sentinel errors in db pkg      | ErrNotFound, ErrConflict  | Decouples upper layers from pgx error types                  |
| 29 | Auth service repo interface    | Duck-typed Repository     | Pure Go mock in tests; no pgxmock needed at service layer    |
| 30 | Login error mapping            | ErrInvalidCredentials     | Same error for bad email/password; prevents enumeration      |
