# Design: Pet Store

## Overview

This document describes *how* the Pet Store application is
built. It is the implementation companion to
[REQUIREMENTS.md](REQUIREMENTS.md), which describes *what*
the system does.

Every section in REQUIREMENTS.md should have a corresponding
design detail here. When making implementation changes,
update this document to keep it in sync.

## System Architecture

The application follows a classic three-tier architecture:

```
┌────────────────┐     ┌────────────────┐     ┌────────────┐
│  React + TS    │────▶│  Go Backend    │────▶│ PostgreSQL │
│  (Vite, TW)   │ HTTP│  (ogen router) │ SQL │            │
│  Port 5173     │◀────│  Port 8080     │◀────│  Port 5432 │
└────────────────┘     └────────────────┘     └────────────┘
     Frontend              Backend               Database

┌────────────────┐
│  Go Client     │─── HTTP ───▶ Go Backend
│  (ogen client) │
└────────────────┘
```

- **Frontend** — React SPA served by Vite in dev; talks to
  the backend over HTTP (JSON).
- **Backend** — Go HTTP server with routing, validation, and
  serialization generated by ogen from the OpenAPI spec.
  Business logic lives in hand-written service and
  repository layers.
- **Go Client** — Generated Go HTTP client for the API,
  also produced by ogen from the same OpenAPI spec. Lives
  in the `client/` package at the project root. Used for
  CLI tooling, integration tests, and any Go consumer of
  the API.
- **Database** — PostgreSQL stores pets and users. Accessed
  only by the backend through `jackc/pgx/v5` (native pgx
  interface, no `database/sql` wrapper).

All tiers are independently deployable and communicate
over well-defined interfaces (HTTP, SQL).

## Backend Design

### Project Layout

```
cmd/
  server/
    main.go              # Server entrypoint
  client/
    main.go              # Client CLI entrypoint
client/
  oas_*.go               # ogen-generated client (DO NOT EDIT)
internal/
  api/
    api.yml              # OpenAPI 3.0 spec (source of truth)
    generate.go          # go:generate directives for ogen
    ogen-server.yml      # ogen config: server-only generation
    ogen-client.yml      # ogen config: client-only generation
    oas_*.go             # ogen-generated server (DO NOT EDIT)
  db/
    db.go                # DBTX interface, sentinel errors
  handler/
    handler.go           # Implements ogen Handler interface
  auth/
    user.go              # User domain model (private fields)
    repository.go        # UserRepository (DB queries) ✓
    security.go          # ogen SecurityHandler (JWT) ✓
    service.go           # AuthService (register, login) ✓
    service_test.go      # Service tests (mock repo) ✓
    authz.go             # RequireAdmin() helper ✓
    jwt.go               # Token creation and parsing ✓
    jwt_test.go          # JWT tests ✓
    context.go           # Context keys, ClaimsFromContext() ✓
    context_test.go      # Context round-trip tests ✓
  pet/
    repository.go        # PetRepository (DB queries) ✓
    service.go           # PetService (CRUD logic) ✓
scripts/
  migrate.sh               # Migration runner (sets session vars)
migrations/
  000001_create_pets_table.up.sql
  000001_create_pets_table.down.sql
  000002_create_users_table.up.sql
  000002_create_users_table.down.sql
```

### ogen Workflow

The OpenAPI spec (`internal/api/api.yml`) is the single
source of truth for the API contract. Both server and
client code are generated from the same spec using
separate ogen configurations.

```
                    ┌─ ogen-server.yml ─▶ internal/api/oas_*.go
api.yml ──▶ ogen ──┤
                    └─ ogen-client.yml ─▶ client/oas_*.go
```

Generation is triggered via `go generate`:

```bash
mise run generate        # or: go generate ./internal/api/...
```

The `internal/api/generate.go` file contains two
`//go:generate` directives — one per ogen config.

**Server generation** (`ogen-server.yml`):
- `Handler` interface with one method per operation
- `SecurityHandler` interface for the `cookieAuth` scheme
- Router, parameter parsing, and request validation
- Server constructor: `ogen.NewServer(handler, security)`
- Unimplemented stub handler for scaffolding

**Client generation** (`ogen-client.yml`):
- Type-safe client struct with one method per operation
- Request/response types matching the spec schemas
- Client-side request validation

**Implementation rule:** Never edit generated `oas_*.go`
files in either `internal/api/` or `client/`. Implement
the `Handler` and `SecurityHandler` interfaces in separate
packages.

### Layered Architecture

```
HTTP request
  │
  ▼
ogen router + validation (generated)
  │
  ▼
Handler (thin — delegates to services)
  │
  ▼
Service (business logic, orchestration)
  │
  ▼
Repository (SQL queries, data mapping)
  │
  ▼
PostgreSQL
```

Each layer depends only on the layer below it. Handlers
never touch SQL directly. Services receive repository
interfaces for testability.

### Error Handling

- Return errors up the call stack; never `panic` in
  request-handling code.
- Wrap errors with context:
  `fmt.Errorf("pet service: find by id: %w", err)`
- Use sentinel errors (e.g., `ErrNotFound`, `ErrConflict`)
  in the repository layer; services and handlers translate
  these to HTTP status codes.
- ogen handles serialization of error responses using the
  `Error` schema (`code` + `message`).

### Structured Logging

- Use `log/slog` from the standard library.
- Create a logger in `main.go` and pass it via context or
  struct injection — no global logger.
- Log at appropriate levels:
  - `INFO` — request lifecycle, auth events
  - `WARN` — recoverable issues (e.g., rate limit hit)
  - `ERROR` — unrecoverable failures
- Never log passwords, tokens, or password hashes.

## Authentication & Authorization Design

### JWT Lifecycle

```
Register ──▶ Login ──▶ Cookie set ──▶ Request + cookie
                                          │
                                          ▼
                                    SecurityHandler
                                    validates JWT
                                          │
                                          ▼
                                    Handler runs
                                          │
                                          ▼
                                    Logout clears cookie
```

1. User registers via `POST /auth/register` (no auth).
2. User logs in via `POST /auth/login`; server returns
   an `access_token` HttpOnly cookie containing a JWT.
3. Subsequent requests include the cookie automatically.
4. The ogen `SecurityHandler` extracts and validates the
   JWT on protected endpoints.
5. Logout via `POST /auth/logout` clears the cookie by
   setting `MaxAge=0`.

### SecurityHandler Implementation

ogen generates a `SecurityHandler` interface with a
`HandleCookieAuth` method. The implementation in
`internal/auth/security.go`:

1. Parses and validates the JWT via
   `TokenConfig.ParseToken()` (signature, expiration).
2. Extracts `Claims` (`UserID`, `Role`).
3. Checks an `adminOperations` map — since ogen does not
   populate `CookieAuth.Roles` from `x-required-role`, the
   handler maintains its own map of operations that require
   the `admin` role (`AddPet`, `DeletePet`).
4. Stores `Claims` in the request context via
   `ContextWithClaims()`.
5. Returns `ErrInvalidToken` (401) or `ErrForbidden` (403)
   on failure.

### Password Hashing Flow

```
Registration:
  plaintext password ──▶ bcrypt.GenerateFromPassword()
                         ──▶ store hash in users.password_hash

Login:
  plaintext password ──▶ bcrypt.CompareHashAndPassword()
                         against stored hash
```

- Library: `golang.org/x/crypto/bcrypt`, default cost.
- The 72-byte bcrypt input limit is enforced at the API
  schema level (`maxLength: 72` on password fields).

### Role Enforcement

- Roles are embedded in the JWT `role` claim.
- The `SecurityHandler` uses an `adminOperations` map to
  determine which operations require the `admin` role
  (ogen does not extract `x-required-role` at runtime).
- A `RequireAdmin()` helper in `internal/auth/authz.go`
  provides a reusable check for handler-level use.
- Role changes require re-login (new JWT) since the role
  is in the token, not looked up per-request.

### Origin Header Validation (CSRF)

- `SameSite=Strict` on the cookie is the primary CSRF
  defense.
- Additionally, state-changing requests (POST, DELETE)
  validate the `Origin` header against `FRONTEND_URL`.
- This check runs in middleware before the handler.

## Database Design

### Table DDL

**pets:**

```sql
CREATE TABLE pets (
    id   BIGSERIAL PRIMARY KEY,
    name TEXT      NOT NULL,
    tag  TEXT
);
```

**users:**

```sql
CREATE TABLE users (
    id            BIGSERIAL    PRIMARY KEY,
    name          TEXT         NOT NULL,
    email         TEXT         NOT NULL,
    password_hash TEXT         NOT NULL,
    role          TEXT         NOT NULL DEFAULT 'customer'
                  CHECK (role IN ('admin', 'customer')),
    created_at    TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_at    TIMESTAMPTZ  NOT NULL DEFAULT now()
);
CREATE UNIQUE INDEX idx_users_email ON users (email);
```

### Indexes

| Index            | Table | Columns | Type   | Purpose              |
|------------------|-------|---------|--------|----------------------|
| `pets_pkey`      | pets  | id      | PK     | Primary key (auto)   |
| `idx_pets_tag`   | pets  | tag     | B-tree | Tag filter queries   |
| `users_pkey`     | users | id      | PK     | Primary key (auto)   |
| `idx_users_email`| users | email   | Unique | Login lookup, dedup  |

### Privilege Grants

The `petstore` application user receives minimal
privileges:

```sql
GRANT SELECT, INSERT, UPDATE, DELETE
    ON pets, users TO petstore;
GRANT USAGE, SELECT
    ON ALL SEQUENCES IN SCHEMA public TO petstore;
```

The `postgres` superuser is used only for migrations and
administrative tasks.

### Migration Strategy

- Tool: `golang-migrate/migrate` with the PostgreSQL
  driver.
- Files live in `migrations/`, numbered sequentially with
  separate up/down files:
  ```
  000001_create_petstore_role.up.sql / .down.sql
  000002_create_pets_table.up.sql    / .down.sql
  000003_create_pets_indexes.up.sql  / .down.sql
  000004_create_users_table.up.sql   / .down.sql
  000005_create_users_indexes.up.sql / .down.sql
  000006_grant_petstore_privileges.up.sql / .down.sql
  ```
- Each table creation and its indexes are in separate
  migrations.
- Migration 000001 creates the `petstore` role using
  `current_setting('migration.petstore_password')`. The
  Go migration runner must `SET` this session variable
  from the `PETSTORE_PASSWORD` env var before running
  migrations.
- **Dev:** Migrations run automatically on server startup.
- **Prod:** Migrations run explicitly via CLI before deploy.
- Down migrations exist for every up migration to support
  rollback.
- The `scripts/migrate.sh` wrapper builds a `DATABASE_URL`
  with the `options` parameter to `SET`
  `migration.petstore_password` as a session variable, then
  invokes `migrate up`. It allows `DATABASE_URL` override
  from the environment.

### Docker Volume

The PostgreSQL container uses a named Docker volume
(`petstore-data`) mounted at `/var/lib/postgresql` to
persist data across container restarts. This means
`db:stop` followed by `db:start` retains all data.
`db:clean` explicitly removes the volume for a fresh start.

### Database Lifecycle Tasks

mise provides a set of tasks for managing the database
container:

| Task         | Description                              |
|--------------|------------------------------------------|
| `db`         | Start database and run migrations        |
| `db:start`   | Start container with persistent volume   |
| `db:stop`    | Stop and remove the container            |
| `db:clean`   | Stop container and remove the volume     |
| `db:migrate` | Run migrations via `scripts/migrate.sh`  |

### Connection Management

- Connection string comes from `DATABASE_URL` env var.
- Use `pgxpool.Pool` from `jackc/pgx/v5` for connection
  pooling (native pgx, not `database/sql`).
- Pool settings are configured via `DATABASE_URL`
  parameters or `pgxpool.Config` defaults.

### DBTX Interface

Repositories depend on a `DBTX` interface defined in
`internal/db/db.go`:

```go
type DBTX interface {
    Query(ctx context.Context, sql string,
        args ...any) (pgx.Rows, error)
    QueryRow(ctx context.Context, sql string,
        args ...any) pgx.Row
    Exec(ctx context.Context, sql string,
        args ...any) (pgconn.CommandTag, error)
}
```

This interface is satisfied by `*pgxpool.Pool`, `pgx.Tx`,
and `pgxmock` — enabling repositories to work with a live
pool, inside a transaction, or under test.

Sentinel errors `db.ErrNotFound` and `db.ErrConflict` let
upper layers translate to HTTP status codes without
importing pgx.

### Transaction Boundaries

- Registration (insert user) runs in a single query — no
  explicit transaction needed.
- Operations touching multiple tables use explicit
  transactions via `pgx.Tx`.
- Repository methods accept the `DBTX` interface,
  compatible with both `*pgxpool.Pool` and `pgx.Tx`.

### Pet Domain Model

`internal/pet/pet.go` defines a `Pet` struct with domain
types (`*string` for the nullable tag) rather than
ogen-generated types. This decouples the pet package from
the API layer, matching the auth package's approach.

### Pet Repository

`internal/pet/repository.go` — returns `pet.Pet` domain
types. The nullable `tag` column scans directly into
`*string`.

| Method     | SQL                                  | Notes                                |
|------------|--------------------------------------|--------------------------------------|
| `Create`   | `INSERT ... RETURNING id, name, tag` | Scans tag directly into `*string`    |
| `FindByID` | `SELECT ... WHERE id = $1`           | Returns `db.ErrNotFound` on no row   |
| `FindAll`  | `SELECT ...` + dynamic filters       | Optional `tags` (IN) and `limit`     |
| `Delete`   | `DELETE ... WHERE id = $1`           | Returns `db.ErrNotFound` on 0 rows   |

### Pet Service

`internal/pet/service.go` contains the business logic
layer for pets, sitting between the (future) HTTP handler
and the repository layer.

**Interface-based dependency injection:**

The service depends on a `Repository` interface rather than
the concrete `PetRepository`. This enables testing with a
hand-written mock — no pgxmock or database needed:

```go
type Repository interface {
    Create(ctx context.Context,
        name string, tag *string,
    ) (Pet, error)
    FindByID(ctx context.Context,
        id int64,
    ) (Pet, error)
    FindAll(ctx context.Context,
        tags []string, limit *int32,
    ) ([]Pet, error)
    Delete(ctx context.Context,
        id int64,
    ) error
}
```

`PetRepository` satisfies this interface via Go duck
typing — no explicit `implements` declaration needed.

**Constructor:** `NewService(repo Repository) *Service`

**Methods:**

| Method      | Inputs                    | Returns         | Notes                    |
|-------------|---------------------------|-----------------|--------------------------|
| `CreatePet` | ctx, name, tag            | `Pet, error`    | Delegates to repo.Create |
| `GetPet`    | ctx, id                   | `Pet, error`    | Delegates to repo.FindByID |
| `ListPets`  | ctx, tags, limit          | `[]Pet, error`  | Delegates to repo.FindAll |
| `DeletePet` | ctx, id                   | `error`         | Delegates to repo.Delete |

### Pet Service Tests

`internal/pet/service_test.go` uses an external test
package (`package pet_test`) with a hand-written `mockRepo`
implementing the `Repository` interface. Each mock function
is set per-test via function fields.

Table-driven test cases:

| Test                  | Case       | Assertion                      |
|-----------------------|------------|--------------------------------|
| `TestServiceCreatePet`| success    | Returns pet with correct fields|
| `TestServiceCreatePet`| repo error | Returns error                  |
| `TestServiceGetPet`   | found      | Returns pet with correct ID    |
| `TestServiceGetPet`   | not found  | Returns `db.ErrNotFound`       |
| `TestServiceListPets` | success    | Returns expected count         |
| `TestServiceListPets` | empty      | Returns nil slice              |
| `TestServiceDeletePet`| success    | Returns nil error              |
| `TestServiceDeletePet`| not found  | Returns `db.ErrNotFound`       |

### User Repository

`internal/auth/repository.go` — returns `auth.User`
domain model (contains `PasswordHash` and timestamps
that must not leak to the API).

| Method        | SQL                              | Notes                                       |
|---------------|----------------------------------|---------------------------------------------|
| `Create`      | `INSERT ... RETURNING id, ...`   | Returns `db.ErrConflict` on unique violation |
| `FindByEmail` | `SELECT ... WHERE email = $1`    | Returns `db.ErrNotFound` on no row           |
| `FindByID`    | `SELECT ... WHERE id = $1`       | Returns `db.ErrNotFound` on no row           |

### User Domain Model

`internal/auth/user.go` defines a `User` struct separate
from `api.AuthUser`. It includes `PasswordHash`,
`CreatedAt`, and `UpdatedAt` — fields that must never
appear in API responses. Mapping from `User` to
`api.AuthUser` happens in the service layer.

### Auth Service

`internal/auth/service.go` contains the business logic
layer for authentication, sitting between the (future)
HTTP handler and the repository/JWT layers.

**Interface-based dependency injection:**

The service depends on a `Repository` interface rather than
the concrete `UserRepository`. This enables testing with a
hand-written mock — no pgxmock or database needed:

```go
type Repository interface {
    Create(ctx context.Context,
        name, email, passwordHash, role string,
    ) (User, error)
    FindByEmail(ctx context.Context,
        email string,
    ) (User, error)
    FindByID(ctx context.Context,
        id int64,
    ) (User, error)
}
```

`UserRepository` satisfies this interface via Go duck
typing — no explicit `implements` declaration needed.

**Constructor:** `NewService(repo Repository,
token *TokenConfig) *Service`

**Methods:**

| Method     | Inputs                       | Returns            | Notes                                           |
|------------|------------------------------|--------------------|--------------------------------------------------|
| `Register` | ctx, name, email, password   | `User, error`      | Hashes with bcrypt; role is always `"customer"`  |
| `Login`    | ctx, email, password         | `string, User, error` | Returns JWT + user; maps not-found to `ErrInvalidCredentials` |
| `GetUser`  | ctx, id                      | `User, error`      | Delegates to `repo.FindByID`                     |

**Error mapping:**

- `db.ErrNotFound` on login → `ErrInvalidCredentials`
  (prevents email enumeration)
- `db.ErrConflict` on register → propagated as-is
  (handler maps to 409)
- `db.ErrNotFound` on `GetUser` → propagated as-is
  (handler maps to 404)
- bcrypt mismatch on login → `ErrInvalidCredentials`

**Dependencies:** `golang.org/x/crypto/bcrypt` for
password hashing at `bcrypt.DefaultCost`.

### Auth Service Tests

`internal/auth/service_test.go` uses an external test
package (`package auth_test`) with a hand-written
`mockRepo` implementing the `Repository` interface. Each
mock function is set per-test via function fields.

Table-driven test cases:

| Test         | Case             | Assertion                      |
|--------------|------------------|--------------------------------|
| `Register`   | success          | Returns user; password hashed  |
| `Register`   | duplicate email  | Returns `db.ErrConflict`       |
| `Login`      | success          | Returns non-empty JWT + user   |
| `Login`      | unknown email    | Returns `ErrInvalidCredentials`|
| `Login`      | wrong password   | Returns `ErrInvalidCredentials`|
| `GetUser`    | success          | Returns user with correct ID   |
| `GetUser`    | not found        | Returns `db.ErrNotFound`       |

### Auth Context

`internal/auth/context.go` provides helpers to store and
retrieve `Claims` in a `context.Context`, using the
standard unexported-key pattern to avoid collisions.

- **`ContextWithClaims(ctx, Claims) context.Context`** —
  returns a child context carrying the given Claims.
- **`ClaimsFromContext(ctx) (Claims, bool)`** — extracts
  Claims from the context, returning false if absent.

The `SecurityHandler` calls `ContextWithClaims` after
validating the JWT, and downstream handlers call
`ClaimsFromContext` to access the authenticated user's ID
and role without a database lookup.

Only `Claims` (UserID + Role) is stored — not the full
`User` — because the SecurityHandler only has the JWT.
Handlers that need the full user can call
`service.GetUser()`.

## Frontend Design

### Component Hierarchy

```
App
├── AuthProvider (Context + useReducer)
│   ├── NavBar
│   │   ├── Logo / Home link
│   │   ├── User name + role (when logged in)
│   │   └── Login / Register links (when logged out)
│   ├── Routes
│   │   ├── /login         → LoginPage
│   │   ├── /register      → RegisterPage
│   │   ├── /pets           → PetListPage
│   │   ├── /pets/:id       → PetDetailPage
│   │   ├── /pets/new       → AddPetPage (protected, admin)
│   │   └── *               → NotFoundPage
│   └── ToastContainer (success/error feedback)
```

### Routing Structure

React Router handles client-side routing. Routes are split
into public and protected:

| Path           | Component      | Auth     | Role  |
|----------------|----------------|----------|-------|
| `/login`       | LoginPage      | Public   | —     |
| `/register`    | RegisterPage   | Public   | —     |
| `/pets`        | PetListPage    | Public   | —     |
| `/pets/:id`    | PetDetailPage  | Public   | —     |
| `/pets/new`    | AddPetPage     | Required | Admin |

### Auth State Management

```
AuthContext (React Context)
  │
  ├── state: { user: AuthUser | null, loading: boolean }
  │
  └── dispatch: (action) => void
       ├── LOGIN_SUCCESS  → set user
       ├── LOGOUT         → clear user
       └── SET_LOADING    → toggle loading
```

- `AuthProvider` wraps the app and calls `GET /auth/me` on
  mount to restore session from the HttpOnly cookie.
- Components access auth state via a `useAuth()` hook.
- Login sets user state; logout clears it and calls
  `POST /auth/logout`.

### Service Layer Pattern

All API calls go through `frontend/src/services/`. No
component calls `fetch` directly.

```
frontend/src/services/
  api.ts          # Base fetch wrapper (credentials, JSON)
  petService.ts   # findPets, getPet, addPet, deletePet
  authService.ts  # register, login, logout, getCurrentUser
```

The base `api.ts` module:
- Sets `credentials: 'include'` for cookie handling.
- Sets `Content-Type: application/json`.
- Parses error responses into a consistent format.
- Provides typed wrapper functions for GET, POST, DELETE.

### Protected Route Redirect Flow

```
User visits /pets/new (protected)
  │
  ├── Not authenticated?
  │     └── Redirect to /login?redirect=/pets/new
  │           └── After login → redirect to /pets/new
  │
  └── Authenticated but not admin?
        └── Redirect to /pets (or show 403 message)
```

A `ProtectedRoute` wrapper component checks auth state
and role before rendering the child route.

## API Design

### Base Path and CORS

- All endpoints are served under `/api/v1/` (ogen base
  path configuration).
- CORS middleware allows requests from `FRONTEND_URL` with:
  - Allowed methods: GET, POST, DELETE, OPTIONS
  - Allowed headers: Content-Type
  - Credentials: true (for cookies)
  - Max age: 3600s

### Request/Response Flow

```
Client request
  │
  ▼
CORS middleware
  │
  ▼
ogen router (matches path + method)
  │
  ▼
ogen parameter parsing + validation
  │
  ▼
ogen SecurityHandler (if endpoint has security)
  │
  ▼
Handler method (generated interface)
  │
  ▼
ogen response serialization
  │
  ▼
Client response
```

### Error Response Format

All errors use the `Error` schema:

```json
{
  "code": 404,
  "message": "pet not found"
}
```

Standard HTTP status codes:
- `200` — success (list, get, login)
- `201` — created (register)
- `204` — no content (delete, logout)
- `400` — bad request (validation failure)
- `401` — unauthorized (missing/invalid token)
- `403` — forbidden (insufficient role)
- `404` — not found
- `409` — conflict (duplicate email)
- `500` — internal server error

### Cookie Handling

- **Login:** Response sets `Set-Cookie: access_token=<jwt>`
  with HttpOnly, Secure, SameSite=Strict, Path=/,
  MaxAge=3600.
- **Logout:** Response sets the same cookie with
  `MaxAge=0` to clear it.
- **Secure flag:** `true` in production; configurable to
  `false` in dev (plain HTTP on localhost).

## Go Client Design

### Purpose

The Go client provides a type-safe, generated HTTP client
for the Pet Store API. It is used by:
- The CLI tool (`cmd/client/main.go`)
- Integration tests that exercise the API end-to-end
- Any future Go service that consumes the API

### Package Layout

```
client/
  oas_*.go       # ogen-generated client code (DO NOT EDIT)
cmd/
  client/
    main.go      # CLI entrypoint
```

The `client/` package lives at the project root (not under
`internal/`) so it can be imported by external Go modules
if needed.

### Code Generation

Client code is generated from the same `api.yml` spec as
the server, using a separate ogen config
(`internal/api/ogen-client.yml`) that enables only
client-related features:

- `paths/client` — client struct and methods
- `client/request/validation` — validate requests before
  sending

The `--clean` flag ensures stale generated files are
removed on each run. Generation is controlled by
`internal/api/generate.go` and invoked via
`mise run generate`.

### Cookie / Auth Handling

The ogen-generated client accepts a `SecuritySource`
interface for authentication. The client implementation
provides the `access_token` cookie value obtained from a
prior login call. Cookie jar management or manual header
injection can be used depending on the use case.

## Configuration & Environment

### 12-Factor Approach

The application follows
[12-Factor App](https://12factor.net/) principles:

| Factor           | Implementation                      |
|------------------|-------------------------------------|
| Codebase         | Single repo, git                    |
| Dependencies     | go.mod, package.json                |
| Config           | Environment variables               |
| Backing services | PostgreSQL via DATABASE_URL          |
| Build/release/run| mise tasks, Vite build              |
| Processes        | Stateless server                    |
| Port binding     | PORT env var                        |
| Concurrency      | Go goroutines per request           |
| Disposability    | Graceful shutdown on SIGTERM        |
| Dev/prod parity  | Same stack, minimal differences     |
| Logs             | Structured JSON to stdout           |
| Admin processes  | Migration CLI, seed scripts         |

### Secrets Management

- Secrets (`POSTGRES_PASSWORD`, `PETSTORE_PASSWORD`,
  `JWT_SECRET`) are stored in
  `.config/mise/mise.local.toml`, which is gitignored.
  Values use mise's age encryption (`{ age = "..." }`
  syntax).
- Never committed in plaintext or stored in `.env` files
  in version control. The local config file stays on the
  developer's machine only.
- Accessed at runtime via `mise env` which decrypts and
  injects them into the process environment.

### Dev vs. Prod Differences

| Concern             | Dev                | Prod             |
|---------------------|--------------------|------------------|
| Cookie Secure flag  | `false`            | `true`           |
| Migrations          | Auto-run on start  | CLI before deploy|
| Log format          | Text (human-read)  | JSON             |
| Frontend            | Vite dev server    | Static build     |
| CORS origin         | `localhost:5173`   | Production URL   |

## Testing Strategy

### Go Tests

- **Style:** Table-driven tests using `testing.T` and
  subtests (`t.Run`).
- **Service tests:** Mock the repository interface; test
  business logic in isolation.
- **Handler tests:** Use `httptest` to spin up the ogen
  server with real handlers and mock services.
- **Repository tests:** Unit tests using `pgxmock` to mock
  the `DBTX` interface; no live database required.
- **Auth tests:** Token creation/parsing, expired token
  rejection, role enforcement, bcrypt round-trip.
- **Run:** `mise run api:test` (wraps `go test ./...`).

### Frontend Tests

- **Component tests:** React Testing Library for
  rendering and user interaction.
- **Service layer tests:** Mock `fetch` to verify correct
  request construction and response parsing.
- **Auth flow tests:** Verify context updates on login/
  logout, protected route redirects.
- **Run:** `mise run ui:test`.

### Auth-Specific Test Cases

| Scenario                     | Expected Result         |
|------------------------------|-------------------------|
| Valid JWT                    | Request proceeds        |
| Expired JWT                  | 401 Unauthorized        |
| Tampered JWT signature       | 401 Unauthorized        |
| Missing cookie               | 401 Unauthorized        |
| Customer accessing admin ep  | 403 Forbidden           |
| Admin accessing admin ep     | Request proceeds        |
| Login with wrong password    | 401 Unauthorized        |
| Register with duplicate email| 409 Conflict            |
| Password > 72 bytes          | 400 Bad Request         |
| Rate limit exceeded          | 429 Too Many Requests   |

## Decision Log

| #  | Decision                       | Choice                    | Rationale                                                    |
|----|--------------------------------|---------------------------|--------------------------------------------------------------|
| 1  | API specification tool         | ogen (OpenAPI 3.0)        | Type-safe generated server; spec is single source of truth   |
| 2  | GET /pets public access        | No auth required          | Allows browsing without account                              |
| 3  | Auth token delivery            | HttpOnly cookie           | Prevents XSS token theft; browser sends automatically        |
| 4  | JWT algorithm                  | HS256                     | Simple shared-secret; sufficient for single-service deploy   |
| 5  | Refresh tokens                 | None; 1hr access token    | Simpler implementation; re-login on expiry                   |
| 6  | CSRF protection                | SameSite=Strict + Origin  | Strongest browser protection; no separate token needed       |
| 7  | Role storage                   | JWT claims                | Avoids DB lookup per request; role changes require re-login  |
| 8  | Password hashing               | bcrypt, default cost      | Industry standard; 72-byte limit enforced in schema          |
| 9  | Admin creation                 | Manual / seed script      | No self-service admin promotion                              |
| 10 | Database migration tool        | golang-migrate            | SQL-based, supports up/down, widely adopted                  |
| 11 | Frontend state management      | Context + useReducer      | Built-in React; avoids external dependency for simple state  |
| 12 | CSS framework                  | Tailwind CSS              | Utility-first; consistent with project conventions           |
| 13 | Frontend routing               | React Router              | De facto standard for React SPAs                             |
| 14 | API base path                  | /api/v1/                  | Versioned; separates API from frontend routes                |
| 15 | Logging                        | slog (std library)        | No external dependency; structured output                    |
| 16 | DB driver                      | pgx/v5 (native)           | Direct pgx interface; no database/sql overhead               |
| 17 | Dev migration strategy         | Auto-run on startup       | Fast iteration; prod uses explicit CLI                       |
| 18 | Service layer pattern          | Interface-based           | Enables mock injection for testing                           |
| 19 | Rate limiting                  | Per-IP on auth endpoints  | Mitigates brute-force without external infrastructure        |
| 20 | Secrets management             | mise.local.toml (gitignored, age-encrypted) | Never in repo; decrypted at runtime by mise          |
| 21 | Go client generation           | ogen from same spec       | Type-safe client; single source of truth for both sides      |
| 22 | Client package location        | `/client` (root)          | Importable by external modules; separate from internal code  |
| 23 | Separate ogen configs          | server.yml + client.yml   | Independent feature sets; server doesn't ship client code    |
| 24 | Repository DB abstraction      | DBTX interface            | Works with pool, transaction, or mock; no concrete dep       |
| 25 | Repository test approach       | pgxmock (unit tests)      | Fast, no live DB; validates SQL expectations                 |
| 26 | Pet repo return type           | pet.Pet domain model      | Decouples pet pkg from ogen; handler maps to api types       |
| 27 | User repo return type          | auth.User domain model    | Keeps PasswordHash/timestamps out of API layer               |
| 28 | Sentinel errors in db pkg      | ErrNotFound, ErrConflict  | Decouples upper layers from pgx error types                  |
| 29 | Auth service repo interface    | Duck-typed Repository     | Pure Go mock in tests; no pgxmock needed at service layer    |
| 30 | Login error mapping            | ErrInvalidCredentials     | Same error for bad email/password; prevents enumeration      |
